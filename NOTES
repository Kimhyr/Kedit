#

## Theorems

### The cursor only points to a gap, except when the buffer is empty.

Every operation the cursor does, the cursor moves to the closest bit based on
its context. For example, after erasing at the start of an empty segment, the
cursor tries to fall, then jump if falling fails.

## Writing

If the segment is empty, throw an `OUT_OF_RANGE` error.

If the cursor is hanging, and the current segment is full: if the next segment
is not empty, create a new segment after the current segment. Climb to the next
segment. If the segment is not full, nothing should be done.

If the cursor is holding, and there exists a empty prior segment, drop to the
prior segment; otherwise, create a segment before the current segment, then
drop to that new prior segment.

If the cursor is climbing, split the segment.

## Erasing

If the cursor is resting, and the segment is not empty, shift the segment.
Afterwards, if the segment is empty, move the cursor to the closest segment
with mass; if the cursor is at the root segment, try climbing. If the segment
is empty, throw an error. If anything else, leave the cursor be.

## Keybindings

* Keybinds should be modal.
* Keybinds aren't based off their operation (e.g. `b` for "back");
  keybinds are based off how good the location is.
* CAPS is the mode switcher.
	- insert and
	- normal mode.
* Keymaps:
	- BitMovement:
		* `J` Move down
		* `K` Move up
		* `L` Move right
		* `;` Move left
	- ByteMovement (move per token/line):
		* `CTRL + BitMovement`
	- SelectMovement ():
		* SHIFT + [BitMovement|BlockMovement]

